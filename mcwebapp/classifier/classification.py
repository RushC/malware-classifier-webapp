from .malware_classifier.malware_classifier.classification import load_classifier
from .malware_classifier.malware_classifier.parsing import memoize
from .malware_classifier.malware_classifier.storage import search
from .models import JobResult, JobUpdate, SampleClass

import base64
import csv
import json
import os

###############################################################################

# The folder where all of the classifiers are stored.
_classifiers_folder = 'classifier/classifiers'

_data_folder = 'classifier/data'

# A temp folder for storing temporary files. All files stored here better get
# cleaned up. 
_temp_folder = 'classifier/temp'

###############################################################################

def classify_exe(sample, job):
    """Classify the sample for the specified job."""
    
    # Note: In order to keep the client updated, we can this process in stages 
    #       instead of just implementing some crazy one liner. Luckily, thanks
    #       to the memoize functionality, we should not see much of a
    #       performance hit due to some redundance.
    
    # Working job result.
    job_result = JobResult(job=job)
    
    # Attempt to create the assembly view for the file.
    update(job, 'Disassembling file...')
    
    # NOTE: If Capstone is not installed on the host computer, this will fail.
    #       We can simply catch the exception for now, but when the 
    #       classification requires assembly features, the try catch should be
    #       removed.
    try:
        job_result.asm_view = sample.assembly_view()
        
    except Exception as e:
        update(job, 'Failed to disassemble file.')
        print('Disassembly failure: ' + str(e))
        
    # Create the hex view for the sample.
    update(job, 'Generating hex view...')
    
    job_result.hex_view = sample.hex_view_formatted()
    
    # Create the image for the sample. In order to retireve the properly
    # formatted image data, we can save a png file, load it back in, and encode
    # the contents in base64. When a client receives this string, they can set
    # the src of an img element directly to it to display the image.
    update(job, 'Creating image...')
    
    image_file_path = os.path.join(_temp_folder, sample.identifier)
    sample.save_image(image_file_path)
    
    image_file_path += '.png'    # save_image appends the .png extension
    with open(image_file_path, 'rb') as file:
        job_result.image = base64.b64encode(file.read())
        
    os.remove(image_file_path)   # Cleaning up temp like a good samaratin
    
    # Extract all of the features from the sample.
    update(job, 'Extracting features...')

    features = sample.features()
    
    # Classify the sample.
    update(job, 'Classifying sample...')
    
    classifier = get_exe_classifier()
    classification = classifier.classify(features)
    job_result.confidence = classifier.predict(features)[int(classification)-1]
    job_result.sample_class = SampleClass.objects.get(
                                  sample_class_label=classification, 
                                  file_type='exe')
    
    # Search for the 3 most similar samples.
    update(job, 'Searching for closest samples...')
    
    feature_matrix = get_exe_feature_matrix()
    search_result = search(feature_matrix, features, num_samples=3)
    job_result.search_results = json.dumps(search_result)
    
    # Save the job results.
    job_result.save()
    
###############################################################################

@memoize
def get_exe_classifier():
    """Load the classifier used to classify executable files."""
    
    classifier_path = os.path.join(_classifiers_folder, 'exe.clsf')
    return load_classifier(classifier_path)

###############################################################################

@memoize
def get_exe_feature_matrix():
    """Load the feature matrix for the Windows Executable samples to be used
    for the features search.
    """
    
    feature_matrix_file_path = os.path.join(_data_folder, 'exe.csv')
    with open(feature_matrix_file_path) as file:
        reader = csv.reader(file)
        return [row[:1] + [float(feature) for feature in row[1:]] 
                for row in reader]

###############################################################################

def update(job, message):
    """Create a job update with the specified message for the job with the 
    specified ID.
    """
    JobUpdate(job=job, message=message).save()
    